#! /bin/bash

DIR=`dirname "$0"`
COMMAND=`basename "$0"`

# ----------------------------------------------------------------------------

AWK_SCRIPT=`mktemp -t "rec_XXXXXXXXXX"`

cat > $AWK_SCRIPT << \EOF
# this awk script extracts memtime results and prints a quadruple of values:
# "exit_status, TIM, MEM, RSS" ; exit_status is an integer or "timeout";
# TIM is the elapsed time displayed by the "memtime" command;
# MEM and RSS are the corresponding values displayed by the "memtime" command;
# this script imports the value of the DURATION variable, which is set only
# if timeouts may occur.

BEGIN {
	FS = " "
	EXIT_STATUS = "unexpected"
}

/Exit \[[0-9][0-9]*\]$/ {
	# in most case, "Exit [n]" occurs at the beginning of the line;
	# however, "Exit [124]" (i.e., timeout) may interrupt and terminate
	# a line that displays output result
	sub (".*Exit \\[", "", $0)
	sub ("\\]", "", $0)
	if ($0 == 124) {
		# execution has been halted by the "timeout" command
		EXIT_STATUS = "timeout"
	} else {
		# execution completed normally (if STATUS == 0) or an
		# error occured (stack overflow, out of memory, segv)
		EXIT_STATUS = $0
	}
}

/^Killed \[[0-9][0-9]*\]$/ {
	sub ("Killed \\[", "", $0)
	sub ("\\]", "", $0)
	EXIT_STATUS = "kill-" $0
}

/Killed \[9\]$/ {
	# case of a CafeObj execution, in which the interpreter must be halted
	# by the "timeout" command using the uncatchable signal SIGKILL (= 9);
	# the string "Killed [9]" does not necessarily occur at the beginning
	# of the line; it can arrive everywhere
	EXIT_STATUS = "timeout"
}

/Max VSize.*Max RSS/ {
	# we expect a line generated by Memtime with the following format: 
	# 0.11 user, 0.01 system, 0.23 elapsed -- Max VSize = 3948KB, Max RSS = 80KB
	sub ("KB,", "", $0)
	sub ("KB", "", $0)
	print EXIT_STATUS " , " $5 " , " $11 " , " $15
}
EOF

# ----------------------------------------------------------------------------

EXIT() {
rm -f $AWK_SCRIPT
exit $1
}

# ----------------------------------------------------------------------------

if [ "$BASH_VERSION" = "" ]
then
	echo "$COMMAND: this script must be executed using /bin/bash because it uses \$PIPESTATUS"
	EXIT 1
fi

# ----------------------------------------------------------------------------

# synopsis: run [-debug] [-memtime] [-timeout 10] file...

# ----------------------------------------------------------------------------

CHECK() {
	if [ "$2" = "" ]
	then
		echo "environment variable \$$1 is not set"
		EXIT 1
	elif [ ! -d "$2" ]
	then
		echo "cannot find directory $2 given by variable \$$1"
		EXIT 1
	fi
}

# ----------------------------------------------------------------------------

COMPILATION() {
	if [ $DEBUG = 1 ]
	then
		echo "compilation $*"
	fi
}

# ----------------------------------------------------------------------------

EXECUTION() {
	if [ $DEBUG = 1 ]
	then
		echo "execution $*"
	fi
}

# ----------------------------------------------------------------------------

COMPILATION_AND_EXECUTION() {
	if [ $DEBUG = 1 ]
	then
		echo "compilation and execution"
	fi
}

# ----------------------------------------------------------------------------

DIGEST_FILTER() {
case "$LANGUAGE" in 
	"cafeobj-a" | "cafeobj-b" )
		# insert "\nEND-OF-CAFEOBJ-OUTPUT\n" before the banner of
		# "memtime" because CAFEOBJ forgets to print a final "\n"
		# before terminating
		sed -e 's/Exit \[/\nEND-OF-CAFEOBJ-OUTPUT\nExit [/' |
		sed -e 's/Killed \[/\nEND-OF-CAFEOBJ-OUTPUT\nKilled [/' |
		# delete verbose and useless messages emitted by the LISP
		# debugger in case of stack overflow ; these messages may
		# exhaust the current filesystem
		sed -e '/^debugger invoked on a SB-KERNEL::CONTROL-STACK-EXHAUSTED/,/^END-OF-CAFEOBJ-OUTPUT/d'
		;;
	"rascal" | "scala" | "tom-a" | "tom-b" )
		# coalesce repetitive error messages emitted by Java or by 
		# compilers written in Java
		uniq -c | sed -e 's/^[ ]*1 //'
		;;
	* )
		cat
esac
}

# ----------------------------------------------------------------------------

LOG_FILENAME() {
NAME=$1
PHASE=$2
LANGUAGE=$3
if [ "$MEMTIME" = "" ]
then
	echo "/dev/stdout"
else
	if [ "$LANGUAGE" = "aprove" ]
	then
		# here, $PHASE contains AProVE's termination verdict
		echo "$NAME-$LANGUAGE.log"
	else
		echo "$NAME-$LANGUAGE-$PHASE.log"
	fi
fi
}

# ----------------------------------------------------------------------------

MEMTIME_FILTER() {
NAME=$1
PHASE=$2
LANGUAGE=$3
if [ "$MEMTIME" = "" ]
then
	DIGEST_FILTER
else
	LOG_FILE=`LOG_FILENAME $NAME $PHASE $LANGUAGE`
	# we write the complete output to $LOG_FILE and one-line summary
	# (in CSV format) to stdout
	DIGEST_FILTER | tee "$LOG_FILE" | awk -vDURATION=$DURATION -f $AWK_SCRIPT | awk '{ print "'$NAME' , '$PHASE' , '$LANGUAGE' , " $0 }'
fi
}

# ----------------------------------------------------------------------------

FAILED() {
# this procedure imports $COMMAND, $STATUS and $DURATION
NAME=$1
PHASE=$2
LANGUAGE=$3
if [ $STATUS = 0 ]
then
	# this case should never happen
	echo "$COMMAND: unexpected status 0 for $NAME, $PHASE, $LANGUAGE"
	EXIT 1
fi
# record that failure in the $SKIP file (if any)
if [ "$SKIP" != "" ]
then
	if [ $STATUS = 124 ]
	then
		REASON="timeout"
	else
		REASON="failure"
	fi
	FAMILY_NAME=`echo $NAME | sed -e 's/[0-9][0-9]*//'`
	echo "$LANGUAGE $FAMILY_NAME $REASON" >> $SKIP
fi
}

# ----------------------------------------------------------------------------

SHORT_CIRCUIT() {
# check if the same tool has not already failed on smaller benchmarks
# belonging to the same family
NAME=$1
FAMILY_NAME=`echo $NAME | sed -e 's/[0-9][0-9]*//'`
LANGUAGE=$2
if [ "$SKIP" = "" ]
then
	# no skip file exists : no short-circuit
	return 1
fi
REASON=`grep "$LANGUAGE $FAMILY_NAME " $SKIP`
if [ "$REASON" = "" ]
then
	# pair (language, family name) not found : no short-circuit
	return 1
else
	echo "$NAME , comp-exec , $LANGUAGE , skept , $REASON already"
	return 0
fi
}

# ----------------------------------------------------------------------------

DEFAULT_STACK_SIZE=`ulimit -Ss`

case `hostname` in
cime | massif )
	# preliminary: Java
	# note : RASCAL (at least) requires Java 8 at least (and rejects Java 7)
	case `hostname` in
	cime )
		# this machine has 3 Gigabytes RAM
		# $REC_STACK_SIZE must be expressed in kilobytes
		REC_STACK_SIZE=32768		# i.e., 32M
		REC_HEAP_SIZE=1100m

		CLEAN_HACK_HEAP_SIZE=1100m

		JAVA_HOME="$HOME/jdk1.8.0_91"
		JAVA_OPTIONS="-d32 -Xmx${REC_HEAP_SIZE} -Xss${REC_STACK_SIZE}k"
		# JAVA_OPTIONS="-d32 -Xmx1G -Xss32m" # ok, but perhaps too small
		# JAVA_OPTIONS="-d32 -Xmx1200M -Xss256M" # nok, 1200m too large
		# JAVA_OPTIONS="-d32 -Xmx2G -Xss512M" # nok, 2G too large
		# JAVA_OPTIONS="-d32 -Xmx1100m -Xss256m" # ca boucle indefiniment avec Rascal, Scala, Tom
		;;
	massif ) 
		# this machine has 16 Gigabytes RAM (12 Gigabytes are free)
		# $REC_STACK_SIZE must be expressed in kilobyte
		REC_STACK_SIZE=524288		# i.e., 512M
		REC_HEAP_SIZE=8192m

		# dirty provision for Clean-hack: if $CLEAN_HACK_HEAP_SIZE
		# is set to 8192m, the executable generated by clm_hack will
		# fail with a bus error; slightly reducing the value seems
		# to solve the problem
		CLEAN_HACK_HEAP_SIZE=8000m

		JAVA_HOME="$HOME/jdk1.8.0_101"
		JAVA_OPTIONS="-d64 -Xmx${REC_HEAP_SIZE} -Xss${REC_STACK_SIZE}k"
		# JAVA_OPTIONS="-d64 -Xmx1100m -Xss32m"
		;;
	esac

	# override the default stack-size limitation
	# enlarge stack limit for all the tools (not only Java ones)

	ulimit -Ss $REC_STACK_SIZE

	# preliminary: Memtime
	case `hostname` in
	cime ) MEMTIME_PATH="$HOME/MEMTIME/memtime-1.4/bin.iX86" ;;
	massif ) MEMTIME_PATH="$HOME/MEMTIME/memtime-1.4/bin.x64" ;;
	esac

	# APROVE
	APROVE="$HOME/APROVE"
	YICES="$HOME/APROVE/yices-1.0.40"

	# CAFEOBJ
	CAFEOBJ="$HOME/CAFEOBJ"

	# CLEAN
	CLEAN="$HOME/CLEAN/clean"

	# HASKELL
	HASKELL="$HOME/HASKELL"
	GMP_LIB="$HOME/HASKELL/LIB/gmp-6.1.0/.libs"

	# LOTOS and LNT
	CADP="$HOME/CADP"
	CAESAR_ADT_OPTIONS="-silent -indent -numeral -32"

	# MAUDE
	case `hostname` in
	cime ) MAUDE="$HOME/MAUDE/Maude-2.7" ;;
	massif ) MAUDE="$HOME/MAUDE/maude-2.7.1" ;;
	esac

	# mCRL2
	MCRL2="$HOME/MCRL2/mCRL2"

	# MLTON
	MLTON="$HOME/MLTON/mlton-20130715-2"

	# OCAML
	OCAML="$HOME/OCAML"

	# OPAL
	OPAL="$HOME/OPAL/ocs-2.4b"

	# RASCAL
	RASCAL="$HOME/RASCAL"
	RASCAL_JAR="$RASCAL/rascal-shell-stable.jar"

	# SCALA
	SCALA="$HOME/SCALA/scala-2.11.8"
	SCALA_CLASS_PATH="$SCALA/lib/scala-library.jar:."

	# SML
	SML="$HOME/SML"

	# STRATEGO
	STRATEGO="$HOME/STRATEGO/strategoxt-2.1.0"

	# TOM
	TOM="$HOME/TOM/tom-2.10"
	TOM_CLASS_PATH="$TOM/lib/tom-runtime-full.jar:."
	;;
*) 
	echo "$COMMAND: this script runs on an unknown machine"
	# environment variables should be properly set already
	CHECK CADP "$CADP"
	# CHECK RASCAL "$RASCAL"
	# ... more checks would be needed for the other tools
esac

# Java
# notice that $JAVA_HOME/bin must come first in the $PATH, so as to override
# the default /usr/bin/java (which is version 7 on Debian 8)
export JAVA_HOME
PATH="$JAVA_HOME/bin:$PATH"

# Memtime
# (if "memtime" is used, either the environment variable $MEMTIME should be
# set to point to the memtime executable, or it should be available in the
# path ; we add to $PATH a user-dependent path were "memtime" is installed)
PATH="$PATH:$MEMTIME_PATH"

# APROVE
PATH="$YICES/bin:$PATH"

# CAFEOBJ
# export CAFEOBJ
PATH="$PATH:$CAFEOBJ/bin"

# CLEAN
# export CLEAN
PATH="$PATH:$CLEAN/bin"

# HASKELL
export HASKELL
PATH="$PATH:$HASKELL/bin"
LD_LIBRARY_PATH="$LD_LIBRARY_PATH:$GMP_LIB"

# LOTOS
export CADP
PATH="$PATH:$CADP/com:$CADP/bin.`$CADP/com/arch`"
CADP_RUN="`(cd $DIR/../src ; pwd)`/cadp_run.o"
# to compile $CADP_RUN if it does not already exist
( cd $DIR/../src ; LANG=C ; make ) 2>&1 | grep -v "is up to date"

# MAUDE
# export MAUDE
PATH="$PATH:$MAUDE/bin"

# MLTON
PATH="$PATH:$MLTON/bin"

# mCRL2
PATH="$PATH:$MCRL2/build/stage/bin"

# OCAML
export OCAML
PATH="$PATH:$OCAML/bin"

# OPAL
# export OPAL
PATH="$PATH:$OPAL/dest/bin"

# RASCAL
export RASCAL
PATH="$PATH:$RASCAL"

# SCALA
# export SCALA
PATH="$PATH:$SCALA/bin"

# SML
PATH="$PATH:$MLTON/bin"

# STRATEGO
PATH="$PATH:$STRATEGO/share/strategoxt/bin"

# TOM
# export TOM
PATH="$PATH:$TOM/bin"

# ----------------------------------------------------------------------------

MAIN() {
	if [ "$MEMTIME" = "" ]
	then
		echo ""
		echo "$COMMAND: *** executing $ARG ***"
		echo ""
	fi

	case "$1" in
	*.hs )
		MODEL=`basename "$1" .hs`
		BASE=`dirname "$1"`/$MODEL
		SHORT_CIRCUIT $MODEL "haskell" && return
		COMPILATION
		$MEMTIME $TIMEOUT ghc "$BASE.hs" -o "$BASE" 2>&1 | MEMTIME_FILTER $MODEL "comp" "haskell"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp" "haskell"
			sh $DIR/rec_purge -haskell $BASE
			return
		fi
		EXECUTION
		$MEMTIME $TIMEOUT "$BASE" 2>&1 | MEMTIME_FILTER $MODEL "exec" "haskell"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "exec" "haskell"
			# sh $DIR/rec_purge -haskell $BASE
			# return
		fi
		sh $DIR/rec_purge -haskell $BASE
		;;

	*.icl )
		MODEL=`basename "$1" .icl`
		BASE=$MODEL
		LOC=`dirname "$1"`

		# phase 1: one uses the standard CLEAN compilers

		SHORT_CIRCUIT $MODEL "clean" && return
		COMPILATION
		# to compile $LOC/$BASE.icl, clm must be invoked from the $LOC
		# directory and be given $BASE (not $BASE.icl) as a parameter ;
		# then, we output a "dummy" string because, when clm does a
		# "Heap full" error, the pipe gets unexpectedly broken and
		# this aborts the execution, preventing "clean-hack" from
		# being tested
		( cd "$LOC" ; $MEMTIME $TIMEOUT clm -h $REC_STACK_SIZE "$BASE" -o "$BASE" ; echo "dummy" ) 2>&1 | MEMTIME_FILTER $MODEL "comp" "clean"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp" "clean"
			sh $DIR/rec_purge -clean $LOC/$BASE
			return
		fi
		EXECUTION
		$MEMTIME $TIMEOUT "$LOC"/"$BASE" 2>&1 | MEMTIME_FILTER $MODEL "exec" "clean"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "exec" "clean"
			# sh $DIR/rec_purge -clean $LOC/$BASE
			# return
		fi
		sh $DIR/rec_purge -clean $LOC/$BASE

		# phase 2: one uses the custom script "src/clm-hack"

		SHORT_CIRCUIT $MODEL "clean-hack" && return
		COMPILATION
		# to compile $LOC/$BASE.icl, clm must be invoked from the $LOC
		# directory and be given $BASE (not $BASE.icl) as a parameter
		( cd "$LOC" ; $MEMTIME $TIMEOUT sh ../src/clm-hack $REC_STACK_SIZE $CLEAN_HACK_HEAP_SIZE "$BASE" -o "$BASE" ) 2>&1 | MEMTIME_FILTER $MODEL "comp" "clean-hack"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp" "clean-hack"
			sh $DIR/rec_purge -clean $LOC/$BASE
			return
		fi
		EXECUTION
		$MEMTIME $TIMEOUT "$LOC"/"$BASE" 2>&1 | MEMTIME_FILTER $MODEL "exec" "clean-hack"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "exec" "clean-hack"
			# sh $DIR/rec_purge -clean $LOC/$BASE
			# return
		fi
		sh $DIR/rec_purge -clean $LOC/$BASE

		;;

	*.impl )
		MODEL=`basename "$1" .impl`
		BASE=$MODEL
		LOC=`dirname "$1"`
		SHORT_CIRCUIT $MODEL "opal" && return
		# construction de la signature $BASE.sign
		sh $DIR/rec_to_opal -signature "$BASE" > "$LOC/$BASE.sign"
		COMPILATION
		( cd "$LOC" ; $MEMTIME $TIMEOUT ocs -top "$BASE" main ) 2>&1 | MEMTIME_FILTER $MODEL "comp" "opal"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp" "opal"
			sh $DIR/rec_purge -opal "$LOC/$BASE"
			return
		fi
		EXECUTION
		( cd "$LOC" ; $MEMTIME $TIMEOUT ./main ) 2>&1 | MEMTIME_FILTER $MODEL "exec" "opal"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "exec" "opal"
			# sh $DIR/rec_purge -opal "$LOC/$BASE"
			# return
		fi
		sh $DIR/rec_purge -opal "$LOC/$BASE"
		;;

	*.lnt )
		MODEL=`basename "$1" .lnt`
		BASE=$MODEL
		LOC=`dirname "$1"`
		SHORT_CIRCUIT $MODEL "lnt" && return
		COMPILATION_AND_EXECUTION
		( cd "$LOC" ; $MEMTIME $TIMEOUT lnt.open $CAESAR_ADT_OPTIONS "$BASE" $CADP_RUN ) 2>&1 | MEMTIME_FILTER $MODEL "comp-exec" "lnt"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp-exec" "lnt"
			# sh $DIR/rec_purge -lnt "$LOC/$BASE"
			# return
		fi
		sh $DIR/rec_purge -lnt "$LOC/$BASE"
		;;

	*.lotos )
		MODEL=`basename "$1" .lotos`
		BASE=$MODEL
		LOC=`dirname "$1"`
		SHORT_CIRCUIT $MODEL "lotos" && return
		COMPILATION_AND_EXECUTION
		( cd "$LOC" ; $MEMTIME $TIMEOUT caesar.open $CAESAR_ADT_OPTIONS "$BASE" $CADP_RUN ) 2>&1 | MEMTIME_FILTER $MODEL "comp-exec" "lotos"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp-exec" "lotos"
			# sh $DIR/rec_purge -lotos "$LOC/$BASE"
			# return
		fi
		sh $DIR/rec_purge -lotos "$LOC/$BASE"
		;;

	*.maude )
		COMPILATION_AND_EXECUTION
		MODEL=`basename "$1" .maude`
		BASE=`dirname "$1"`/$MODEL
		SHORT_CIRCUIT $MODEL "maude" && return
		$MEMTIME $TIMEOUT maude "$BASE.maude" 2>&1 | MEMTIME_FILTER $MODEL "comp-exec" "maude"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp-exec" "maude"
			# sh $DIR/rec_purge -maude $BASE
			# return
		fi
		sh $DIR/rec_purge -maude $BASE
		;;

	*.mcrl2 )
		MODEL=`basename "$1" .mcrl2`
		BASE=$MODEL
		LOC=`dirname "$1"`
		GOTO=0

		# mcrl2 with its default (jitty, not jittyc) rewriter

		SHORT_CIRCUIT $MODEL "mcrl2-jitty" && GOTO=1 # return
		if [ $GOTO != 1 ]
		then
			COMPILATION
			$MEMTIME $TIMEOUT mcrl22lps -v "$LOC"/"$BASE".mcrl2 -o "$BASE".lps 2>&1 | MEMTIME_FILTER $MODEL "comp" "mcrl2-jitty"
			STATUS=${PIPESTATUS[0]}
			if [ $STATUS != 0 ]
			then
				FAILED $MODEL "comp" "mcrl2-jitty"
				sh $DIR/rec_purge -mcrl2 $BASE
				# return
				GOTO=1
			fi
		fi
		if [ $GOTO != 1 ]
		then
			EXECUTION
			$MEMTIME $TIMEOUT lps2lts -v "$BASE".lps "$BASE".aut 2>&1 | MEMTIME_FILTER $MODEL "exec" "mcrl2-jitty"
			STATUS=${PIPESTATUS[0]}
			if [ $STATUS != 0 ]
			then
				FAILED $MODEL "exec" "mcrl2-jitty"
				sh $DIR/rec_purge -mcrl2 $BASE
				# return
				GOTO=2
			fi
			if [ $GOTO != 2 -a -f "$BASE".aut ]
			then
				LOG_FILE=`LOG_FILENAME $MODEL "exec" "mcrl2-jitty"`
				# turn the .aut file into a sequential list of actions
				bcg_io "$BASE".aut -sequence - | grep -v "initial.state" >> $LOG_FILE
			fi
		fi
		sh $DIR/rec_purge -mcrl2 $BASE

		# mcrl2 with the "jittyc" rewriter

		SHORT_CIRCUIT $MODEL "mcrl2-jittyc" && return
		COMPILATION "(jittyc)"
		$MEMTIME $TIMEOUT mcrl22lps -v "$LOC"/"$BASE".mcrl2 -o "$BASE".lps 2>&1 | MEMTIME_FILTER $MODEL "comp" "mcrl2-jittyc"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp" "mcrl2-jittyc"
			sh $DIR/rec_purge -mcrl2 $BASE
			return
		fi
		EXECUTION "(jittyc)"
		$MEMTIME $TIMEOUT lps2lts -v "$BASE".lps "$BASE".aut -rjittyc 2>&1 | MEMTIME_FILTER $MODEL "exec" "mcrl2-jittyc"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "exec" "mcrl2-jittyc"
			sh $DIR/rec_purge -mcrl2 $BASE
			return
		fi
		if [ -f "$BASE".aut ]
		then
			LOG_FILE=`LOG_FILENAME $MODEL "exec" "mcrl2-jittyc"`
			# turn the .aut file into a sequential list of actions
			bcg_io "$BASE".aut -sequence - | grep -v "initial.state" >> $LOG_FILE
		fi
		sh $DIR/rec_purge -mcrl2 $BASE
		;;

	*.ml )
		MODEL=`basename "$1" .ml`
		BASE=`dirname "$1"`/$MODEL
		# OCAML with byte code generation and interpretation
		SHORT_CIRCUIT $MODEL "ocaml-interp" && return
		COMPILATION

		# try to use explicitly native "ocamlc" binary 
		# (this was useful for old versions of OCaml < 4.04.0; under
		# more recent versions, ocamlc is a symlink to ocamlc.opt)
		BIN=$OCAML/bin/ocamlc.opt
		if [ ! -x "$BIN" ]
		then
			# explicitly native "ocamlc" binary does not exist
			BIN=$OCAML/bin/ocamlc
		fi

		$MEMTIME $TIMEOUT $BIN "$BASE.ml" -o "$BASE" 2>&1 | MEMTIME_FILTER $MODEL "comp" "ocaml-interp"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp" "ocaml-interp"
			sh $DIR/rec_purge -ocaml $BASE
			return
		fi
		EXECUTION
		$MEMTIME $TIMEOUT ocamlrun "$BASE" 2>&1 | MEMTIME_FILTER $MODEL "exec" "ocaml-interp"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "exec" "ocaml-interp"
			# sh $DIR/rec_purge -ocaml $BASE
			# return
		fi
		sh $DIR/rec_purge -ocaml $BASE
		# OCAML with native code generation and compilation
		SHORT_CIRCUIT $MODEL "ocaml-compil" && return
		COMPILATION

		# try to use explicitly native "ocamlopt" binary
		# (specific to old versions of OCaml < 4.04.0)
		# note: (1) "ocamlopt" is not the best option, as it is a
		# bytecode program that fails on large models (e.g., add8.ml);
		# (2) setting $OCAMLRUNPARAM to "l=256m" solves the problem;
		# (3) but invoking "ocamlopt.opt" that is a genuine binary
		# also solves the problem, but is five times faster than (2),
		# so option (3) is selected

		BIN=$OCAML/bin/ocamlopt.opt
		# try to use explicitly native "ocamlopt" binary 
		# (this was useful for old versions of OCaml < 4.04.0; under
		# more recent versions, ocamlc is a symlink to ocamlc.opt)
		if [ ! -x "$BIN" ]
		then
			# explicitly native "ocamlopt" binary does not exist
			BIN=$OCAML/bin/ocamlopt
		fi

		$MEMTIME $TIMEOUT $BIN "$BASE.ml" -o "$BASE" 2>&1 | MEMTIME_FILTER $MODEL "comp" "ocaml-compil"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp" "ocaml-compil"
			sh $DIR/rec_purge -ocaml $BASE
			return
		fi
		EXECUTION
		$MEMTIME $TIMEOUT "./$BASE" 2>&1 | MEMTIME_FILTER $MODEL "exec" "ocaml-compil"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "exec" "ocaml-compil"
			# sh $DIR/rec_purge -ocaml $BASE
			# return
		fi
		sh $DIR/rec_purge -ocaml $BASE
		;;

	*.mod )
		MODEL=`basename "$1" .mod`
		BASE=`dirname "$1"`/$MODEL

		# determine the TOM version of the benchmark
		TAG=`head -n 1 "$1" | sed -e 's/^-- //'`
		case "$TAG" in
			"CAFEOBJ-A" ) CAFEOBJ_VERSION="cafeobj-a" ;;
			"CAFEOBJ-B" ) CAFEOBJ_VERSION="cafeobj-b" ;;
			* ) echo "$COMMAND: no argument given"
			    EXIT 1
		esac

		SHORT_CIRCUIT $MODEL $CAFEOBJ_VERSION && return
		COMPILATION_AND_EXECUTION
		# on must use "kill -9" as CafeObj protects itself against
		# the signal normally sent by the "timeout" command
		$MEMTIME $TIMEOUT_KILL cafeobj -batch "$BASE.mod" 2>&1 | MEMTIME_FILTER $MODEL "comp-exec" "$CAFEOBJ_VERSION"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp-exec" "$CAFEOBJ_VERSION"
		fi
		sh $DIR/rec_purge -cafeobj $BASE
		;;

	*.now )
		MODEL=`basename "$1" .now`
		BASE=`dirname "$1"`/$MODEL
		GOTO=0

		# measures with SML-NJ

		SHORT_CIRCUIT $MODEL "sml-smlnj" && GOTO=1 # return
		if [ $GOTO != 1 ]
		then
			COMPILATION_AND_EXECUTION "(sml-nj)"
			# we measure the cumulated time taken by nowhere and sml
			( $MEMTIME $TIMEOUT sh << EOF
nowhere "$BASE.now" && sml -Ccm.verbose=false -Ccompiler-mc.warn-non-exhaustive-match=false "$BASE.sml"
EOF
			) 2>&1 | MEMTIME_FILTER $MODEL "comp-exec" "sml-smlnj"
			STATUS=${PIPESTATUS[0]}
			if [ $STATUS != 0 ]
			then
				FAILED $MODEL "comp-exec" "sml-smlnj"
				# sh $DIR/rec_purge -sml $BASE
				# return
			fi
			sh $DIR/rec_purge -sml $BASE
		fi

		# measures with MLTON

		SHORT_CIRCUIT $MODEL "sml-mlton" && return
		COMPILATION "(sml-mlton)"
		# we measure the cumulated time taken by nowhere and mlton
		( $MEMTIME $TIMEOUT sh << EOF
nowhere "$BASE.now" && mlton "$BASE.sml"
EOF
		) 2>&1 | MEMTIME_FILTER $MODEL "comp" "sml-mlton"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp" "sml-mlton"
			sh $DIR/rec_purge -mlton $BASE
			return
		fi
		EXECUTION "(sml-mlton)"
		$MEMTIME $TIMEOUT "$BASE" 2>&1 | MEMTIME_FILTER $MODEL "exec" "sml-mlton"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "exec" "sml-mlton"
			# sh $DIR/rec_purge -mlton $BASE
			# return
		fi
		sh $DIR/rec_purge -mlton $BASE
		;;

	*.rsc )
		MODEL=`basename "$1" .rsc`
		BASE=$MODEL
		LOC=`dirname "$1"`
		GOTO=0

		# measures with RASCAL interpreter

		SHORT_CIRCUIT $MODEL "rascal-interp" && GOTO=1 # return
		if [ $GOTO != 1 ]
		then
			COMPILATION_AND_EXECUTION
			( cd "$LOC" ; $MEMTIME $TIMEOUT java $JAVA_OPTIONS -jar $RASCAL_JAR "$BASE.rsc" ) 2>&1 | MEMTIME_FILTER $MODEL "comp-exec" "rascal-interp"
			STATUS=${PIPESTATUS[0]}
			if [ $STATUS != 0 ]
			then
				FAILED $MODEL "comp-exec" "rascal-interp"
				# sh $DIR/rec_purge -rascal "$LOC/$BASE"
				# return
			fi
			sh $DIR/rec_purge -rascal "$LOC/$BASE"
		fi

		# measures with RASCAL compiler

		SHORT_CIRCUIT $MODEL "rascal-compil" && return
		COMPILATION
		# $LOC/tmpout is a temporary directory created by the compiler
		( cd "$LOC" ; $MEMTIME $TIMEOUT java $JAVA_OPTIONS -jar $RASCAL_JAR --rascalc --bin "tmpout/" --src `pwd` --src "|std:///|" --optimize "$BASE" ) 2>&1 | MEMTIME_FILTER $MODEL "comp" "rascal-compil"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp" "rascal-compil"
			sh $DIR/rec_purge -rascal $BASE
			return
		fi
		EXECUTION
		( cd "$LOC" ; $MEMTIME $TIMEOUT java $JAVA_OPTIONS -jar $RASCAL_JAR --rascal --bin "tmpout/" "$BASE" ) 2>&1 | MEMTIME_FILTER $MODEL "exec" "rascal-compil"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "exec" "rascal-compil"
			# sh $DIR/rec_purge -rascal $BASE
			# return
		fi
		sh $DIR/rec_purge -rascal $BASE
		;;

	*.scala )
		MODEL=`basename "$1" .scala`
		BASE=$MODEL
		LOC=`dirname "$1"`
		SHORT_CIRCUIT $MODEL "scala" && return
		COMPILATION

		# the following (very natural) command would not work:
		# ( cd "$LOC" ; $MEMTIME $TIMEOUT scalac "$BASE.scala" ) 2>&1 | MEMTIME_FILTER $MODEL "comp" "scala"
		# because SCALA seems to play with the signals and catch
		# them; timeouts are respected if the command is read by
		# a shell from its standard input, but not if the command 
		# is called on the command line of "timeout" or contained
		# in a file that is run in batch mode ; in the latter cases,
		# when scalac terminates earlier than the timeout, it waits
		# until the specified timeout has expired

		( sh 2>&1 | MEMTIME_FILTER $MODEL "comp" "scala" ; exit ${PIPESTATUS[0]} ) << EOF
cd "$LOC" ; $MEMTIME $TIMEOUT scalac "$BASE.scala" 
EOF
		STATUS=$?
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp" "scala"
			sh $DIR/rec_purge -scala "$LOC/$BASE"
			return
		fi
		EXECUTION
		# ( cd "$LOC" ; $MEMTIME $TIMEOUT scala "$BASE" ) 2>&1 | MEMTIME_FILTER $MODEL "exec" "scala"
		( cd "$LOC" ; $MEMTIME $TIMEOUT java $JAVA_OPTIONS -cp "$SCALA_CLASS_PATH" "$BASE" ) 2>&1 | MEMTIME_FILTER $MODEL "exec" "scala"
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "exec" "scala"
			# sh $DIR/rec_purge -scala "$LOC/$BASE"
			# return
		fi
		sh $DIR/rec_purge -scala "$LOC/$BASE"
		;;

	*.str )
		COMPILATION_AND_EXECUTION
		MODEL=`basename "$1" .str`
		BASE=`dirname "$1"`/$MODEL
		SHORT_CIRCUIT $MODEL "stratego" && return
		( STRJFLAGS=$JAVA_OPTIONS ; export STRJFLAGS ; $MEMTIME $TIMEOUT str "$BASE.str" 2>&1 | MEMTIME_FILTER $MODEL "comp-exec" "stratego" )
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp-exec" "stratego"
			# sh $DIR/rec_purge -stratego $BASE
			# return
		fi
		sh $DIR/rec_purge -stratego $BASE
		;;

	*.t )
		MODEL=`basename "$1" .t`
		MODEL=`echo $MODEL | $DIR/rec_lower`
		BASE=`basename "$1" .t`
		LOC=`dirname "$1"`

		# determine the TOM version of the benchmark
		TAG=`head -n 1 "$1" | sed -e 's+^// ++'`
		case "$TAG" in
			"TOM-A" ) TOM_VERSION="tom-a" ;;
			"TOM-B" ) TOM_VERSION="tom-b" ;;
			* ) echo "$COMMAND: no argument given"
			    EXIT 1
		esac

		SHORT_CIRCUIT $MODEL $TOM_VERSION && return
		COMPILATION
		# we measure the cumulated time taken by tom and javac
		( cd "$LOC" ; $MEMTIME $TIMEOUT sh << EOF
tom --jCode --pretty "$BASE.t" && javac -cp "$TOM_CLASS_PATH" "$BASE.java"
EOF
		) 2>&1 | MEMTIME_FILTER $MODEL "comp" $TOM_VERSION
		STATUS=${PIPESTATUS[0]}
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "comp" $TOM_VERSION
			sh $DIR/rec_purge -tom "$LOC/$BASE"
			return
		fi
		EXECUTION
		( cd "$LOC" ; $MEMTIME $TIMEOUT java $JAVA_OPTIONS -cp "$TOM_CLASS_PATH" "$BASE" ) 2>&1 | MEMTIME_FILTER $MODEL "exec" $TOM_VERSION
		STATUS=${PIPESTATUS[0]}	
		if [ $STATUS != 0 ]
		then
			FAILED $MODEL "exec" $TOM_VERSION
			# sh $DIR/rec_purge -tom "$LOC/$BASE"
			# return
		fi
		sh $DIR/rec_purge -tom "$LOC/$BASE"
		;;

	*.trs )
		MODEL=`basename "$1" .trs`
		BASE=`dirname "$1"`/$MODEL
		PROOF_FILE="$MODEL-aprove.html"
		# - having $PROOF_FILE in HTML rather than plain text is
		#   better because the colors are helpful to understand
		# - we modify the first line (YES, NO, MAYBE, etc.) written
		#   by AProVE to make sure that $PROOF_FILE is valid HTML
		# - after invoking AProVE, one must wait until its output
		#   $PROOF_FILE is complete before invoking MEMTIME_FILTER
		#   to produce the CSV
		( $MEMTIME $TIMEOUT java -ea -jar $APROVE/aprove.jar -m wst -p html $BASE.trs | sed -e '1s/^\(.*\)$/<!-- \1 -->/' > $PROOF_FILE ) > $MODEL.out 2>&1

		# analyzing the contents of $PROOF_FILE to know whether AProVE
		# has proven termination or not"
		FIRST_LINE=`head -1 "$PROOF_FILE"`
		case "$FIRST_LINE" in
			*YES* )
				TERMINATION="yes" ;;
			*NO* )
				TERMINATION="no" ;;
			*MAYBE* )
				TERMINATION="maybe" ;;
			* )
				TERMINATION="unknown" ;;
		esac

		# looking for signs of crashes in $MODEL.out
		# * Note 1: each line "Running Thread.stop() against..." seems
		#   to be followed by a corresponding line "Aborted..."
		# * Note 2: lines "Aborted ... with a hard timeout" are ok
		#   (dixit Florian Frohn): If one technique does not
		#   terminate within a reasonable amount of time, then it is
		#   killed, leading to error messages on stderr. However, as
		#   the techniques are properly isolated within AProVE, this
		#   does not affect the other techniques or the correctness of
		#   the overall proof
		SUSPICIOUS_LINES=`cat "$MODEL.out" | 
			grep '^[A-Za-z]' | 
			grep -v '^Stack trace:' |
			grep -v '^Threadpool thread died by not catching an exception' |
			grep -v '^java.lang.ThreadDeath' |
			grep -v '^Running Thread.stop() against' |
			grep -v '^Aborted .*with a hard timeout' |
			grep -v '^Exit \[0\]'`
		if [ "$SUSPICIOUS_LINES" != "" ]
		then
			# no spaces around "+" to respect the CSV columns
			TERMINATION="$TERMINATION+crash"
		fi
		# when invoking MEMTIME_FILTER, we use $TERMINATION in place
		# of the phase value ("exec" or "comp") which is meaningless
		cat $MODEL.out | MEMTIME_FILTER $MODEL $TERMINATION "aprove"
		rm -f $MODEL.out
		;;

	* )
		echo "unknown file $1"
		# EXIT 1
	esac
}

# ----------------------------------------------------------------------------

if [ $# -eq 0 ]
then
	echo "$COMMAND: no argument given"
	EXIT 1
fi

# ----------------------------------------------------------------------------

DEBUG=0
if [ "$1" = "-debug" ]
then
	DEBUG=1
	shift
fi
# transmettre -debug

# ----------------------------------------------------------------------------

if [ "$1" = "-memtime" ]
then
	if [ "$MEMTIME" = "" ]
	then
		MEMTIME="memtime"
	fi
	shift
fi

# ----------------------------------------------------------------------------

if [ "$1" = "-timeout" ]
then
	if [ "$2" = "" ]
	then
		echo "$COMMAND: missing argument for -timeout"
		EXIT 1
	fi
	if [ ! -x /usr/bin/timeout ]
	then
		echo "$COMMAND: cannot find /usr/bin/timeout"
		EXIT 1
	fi
	DURATION="$2"
	TIMEOUT="timeout $2"
	TIMEOUT_KILL="timeout -s KILL $2"
	shift 2
fi

# ----------------------------------------------------------------------------

if [ "$1" = "-skip" ]
then
	# the -skip option is intended to save runs; when this option is set,
	# if a tool fails (resp. crashes or times out) on a given instance
	# of a parameterized benchmark (e.g., "add8"), then this tool is
	# assumed to also fail (resp. crash or time out) on all larger
	# instances of the same benchmark (e.g., "add16" and "add32") and
	# is thus not launched on these instances
	if [ "$2" = "" ]
	then
		echo "$COMMAND: missing argument for -skip"
		EXIT 1
	fi
	SKIP="$2"
	shift 2
fi

# ----------------------------------------------------------------------------

if [ $# -eq 0 ]
then
	echo "$COMMAND: no file given"
	EXIT 1
fi

for ARG in "$@"
do
	if [ -f "$ARG" ]
	then
		# cas d'un fichier
		# (ici, les options -duration, -timeout, -skip sont traitees)
		MAIN $ARG
	elif [ -d "$ARG" ]
	then
		# cas d'un repertoire : on itere sur les fichiers qu'il 
		# contient ; sous Linux, l'option "-v" de "ls" permet de 
		# lister les fichiers dans l'ordre intuitif, c'est-a-dire
		# "quicksort10.rec" avant "quicksort100.rec" (et non apres)
		sh $0 `ls -v $ARG/*.* 2> /dev/null`
	else
		# aucun argument fourni
		for SUFFIX in .hs .impl .lnt .lotos .maude .mcrl2 .ml .now .rsc .scala .t
		do
			if [ -f $ARG$SUFFIX ]
			then
				sh $0 $ARG$SUFFIX
			else
				TRY=`ls -v */$ARG$SUFFIX 2> /dev/null`
				if [ "$TRY" != "" ]
				then
					sh $0 $TRY
				fi
			fi
		done
	fi
done

rm -f $AWK_SCRIPT

EXIT 0

# ----------------------------------------------------------------------------


